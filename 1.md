## 1. Generics types as a factory

This pattern is used in **Microsoft.Extensions.\*** and in **Microsoft.AspNetCore.\***. The idea is that you can use a generic type as a factory instead of a function. The type argument is the 
type you want to instantiate. Consider the example below where we have an `IServiceFactory<TService>` that can resolve the `TService` from the DI container or creates an instance if it's 
not in the container.

```C#
public interface IServiceFactory<TService>
{
    TService Service { get; }
}

public class ServiceFactory<TService> : IServiceFactory<TService>
{
    public ServiceFactory(IServiceProvider service)
    {
        Service = (TService)service.GetService(typeof(TService)) ?? ActivatorUtilities.CreateInstance<TService>(service);
    }

    public TService Service { get; private set; }
}
```

The constructor has a access to any service *and* the generic type being requested. These open generic services are registered like this:

```C#
public void ConfigureServices(IServiceCollection services)
{
    services.AddTransient(typeof(IServiceFactory<>), typeof(ServiceFactory<>));
}
```

## 2. Single implementation multiple interfaces in Microsoft.Extensions.DependencyInjection

Let's say you had a type that implemented multiple interfaces and you wanted to expose it using the DI container. The built in `IServiceCollection` type doesn't natively support this but it's easy to emulate using the following pattern.

```C#
public class FooAndBar : IFoo, IBar
{
   // Imagine a useful implementation
}
```

```C#
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton<FooAndBar>();
    services.AddSingleton<IFoo>(sp => sp.GetRequiredService<FooAndBar>());
    services.AddSingleton<IBar>(sp => sp.GetRequiredService<FooAndBar>());
}
```

This will let me resolve `FooAndBar`, `IFoo` and `IBar` and it will give me the same instance.

## 3. Caching singletons in generic types

If you need to cache an instance of something based on type, then you the field on a generic type.

```C#
public class Factory
{
    public T Create<T>()
    {
        return Cache<T>.Instance;
    }
    
    private class Cache<T>
    {
        public T Instance = new T();
    }
}
```

You can use the JIT to cache instances on your behalf instead of a slower `ConcurrentDictionary<Type, T>`.
